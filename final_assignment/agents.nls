__includes [ "messaging.nls" "routing.nls" "voting.nls"]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".

  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  itinerary               ; List of next stations to visit
  target-stop             ; Next stop the bus is driving towards
  called-reinforcements?  ; Flag indicating whether this bus has already called a new bus
  initialized?            ; Flag indicating whether this bus has been initialized yet
  ratio                   ; Ratio of buses to waiting passengers
  ticks-since-init        ; Records the ticks since the bus has been initialized
  blacklisted-stops       ; Records the stops it isn't supposed to use as destination
  capacity                ; Total capacity of bus
  pending-contracts       ; table of open / pending requests to other buses
  assigned-contracts      ; table of requests received by other buses
  reactions               ; List of tasks of function that are used to react to an incoming request by another bus
  known-buses             ; List of other known buses
  disappointments         ; List containing amount of waiting passengers who couldn't be picked up in the 3 previous stops
  bus-fullness            ; List containing amount of passengers in the bus when it departed from 3 previous stops
  passenger-destination-count  ; Table containing the counts of the destination of additional passengers
  known-buses-capacity    ; List containing the capacity of all the buses in teh field
  vote-in-progress?       ; Indicator for a voting session that is in progress
  received-votes          ; Votes received from other buses
  voting-duration         ; Duration of the current vote in ticks
]

extensions [table]
globals [graph]

to init-buses
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  ; 0: Amstel, 1: Amstelveenseweg, 2: Buikslotermeer, 3: Centraal, 4: Dam
  ; 5: Evertsenstraat, 6: Floradorp, 7: Haarlemmermeerstation, 8: Hasseltweg, 9: Hendrikkade,
  ; 10: Leidseplein, 11: Lelylaan, 12: Muiderpoort, 13: Museumplein, 14: RAI, 15: SciencePark, 16: Sloterdijk,
  ; 17: Surinameplein, 18: UvA, 19: VU, 20: Waterlooplein, 21: Weesperplein, 22: Wibautstraat, 23: Zuid

  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]

  set known-buses []
  set known-buses-capacity []
  set blacklisted-stops []
  set pending-contracts table:make
  set assigned-contracts table:make
  set capacity get-capacity
  ; XXX: Add new reaction to requests as tasks here
  set reactions (list (task remember-id) (task remember-size) (task add-to-blacklist) (task remove-from-blacklist) (task cast-vote))
  ; Infrom other buses in the city that you have been created
  tell-buses-id
  tell-buses-size known-buses
  set called-reinforcements? false
  set initialized? true
  set ticks-since-init 0

  set disappointments []
  ; set bus-fullness []

  set passenger-destination-count table:make
  let bus-stop-i 0
  while [bus-stop-i <= 23]
  [
    table:put passenger-destination-count bus-stop-i 0
    set bus-stop-i bus-stop-i + 1
  ]
  set vote-in-progress? false
  set voting-duration 0
  set received-votes []
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.

  ; Check if a new bus should be used
  call-in-reinforcements
  ; Update the ticks since the bus was initialized
  set ticks-since-init ticks-since-init + 1

  ; Message management
  process-inbox
  answer-questions

  ; Check if the bus is just initialized
  ifelse ticks-since-init = 1
  [
      pick-destination
      tell-going-to known-buses
      ; show (word "Destination: " target-stop)
      set itinerary get-path-destination
      ; show (word "New Itinerary: " itinerary)
      pick-up-at-station
  ]
  [
    ifelse current_stop = target-stop
    ; Bus is at a station
    [
      ; show (word "Reached destination " current_stop)
      drop-off-at-station
      tell-reached
      pick-destination
      tell-going-to known-buses
      ; show (word "Destination: " target-stop)
      set itinerary get-path-destination
      ; show (word "New Itinerary: " itinerary)
      pick-up-at-station
    ]
    ; Bus is still on the road
    [
      ; show (word "Still on road at " current_stop)
      ; show (word "Next-stop " next_stop)
      ifelse current_stop = -1
      [
        travel-to next_stop
      ]
      [
        ; show (word "Still on road at " current_stop)
        drop-off-at-station
        pick-up-at-station
        let got-to-stop item 0 itinerary
        set itinerary remove-item 0 itinerary
        ; show (word "Go-to-stop " got-to-stop)
        travel-to got-to-stop
      ]
    ]
  ]
end

;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                             PASSENGER MANAGEMENT
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

to drop-off-at-station
  ;; Drop off all the passengers at station in case it's their destination.
  foreach bus_passengers
  [
    if item 1 ? = current_stop
    [
      drop-off-passenger item 0 ?
      let temp-count table:get passenger-destination-count item 1 ?
      table:put passenger-destination-count item 1 ? temp-count - 1
    ]
  ]
end

to pick-up-at-station
  ;; Pick up all the passengers whose destination is in the itinerary

  let current-disappointments 0  ; Number of passengers that couldn't be picked up at the current station
  let num-removed 0

  set itinerary reverse itinerary

  let passenger-at-destination get-passengers-at-stop current_stop

  foreach passenger-at-destination
  [
    ifelse member? item 1 ? itinerary
    [
        ifelse not bus-full?
        [
            pick-up-passenger item 0 ?
            let temp-count table:get passenger-destination-count item 1 ?
            table:put passenger-destination-count item 1 ? temp-count + 1
        ]
        [
            set num-removed num-removed + try-remove-passenger
            if not bus-full?
            [
                pick-up-passenger item 0 ?
                let temp-count table:get passenger-destination-count item 1 ?
                table:put passenger-destination-count item 1 ? temp-count + 1
            ]
        ]
    ]
    [
        let space-left get-capacity - length bus_passengers
        ifelse space-left > 0
        [
            pick-up-passenger item 0 ?
            let temp-count table:get passenger-destination-count item 1 ?
            table:put passenger-destination-count item 1 ? temp-count + 1
        ]
        [
            let least-prefered-stop get-least-prefered-stop
            if least-prefered-stop != 24
            [
                let least-prefered-stop-count table:get passenger-destination-count least-prefered-stop
                if least-prefered-stop-count < table:get passenger-destination-count item 1 ? + 1
                [
                    set num-removed num-removed + try-remove-passenger
                    if not bus-full?
                    [
                        pick-up-passenger item 0 ?
                        let temp-count table:get passenger-destination-count item 1 ?
                        table:put passenger-destination-count item 1 ? temp-count + 1
                    ]
                ]
            ]
        ]
    ]
  ]

  set itinerary reverse itinerary

  ; Maintain a disappointments list of size 3 which contains the number of passangers who where not satisfied at the current_stop
  if length disappointments = 3 ;or length bus-fullness = 3
  [
    set disappointments but-first disappointments
    ; set bus-fullness but-first bus-fullness
  ]
  set disappointments lput length get-passengers-at-stop current_stop disappointments
  ; set bus-fullness lput length bus_passengers bus-fullness

  ; let passenger-destinations []
  ;
  ; foreach bus_passengers
  ; [
  ;   set passenger-destinations lput item 1 ? passenger-destinations
  ; ]

  ; show (word "Itinerary: " itinerary)
  ; show (word "Current Stop: " current_stop)
  ; show (word "Capacity of the bus: " get-capacity)
  ; show (word "Disappointmented passangers: " disappointments)
  ; show (word "Bus Fullness: " bus-fullness)
  ; show (word "Waiting passangers: " get-passengers-at-stop current_stop)
  ; show (word "Passangers in the bus: " bus_passengers)
  ; show (word "Anticipated pickups: " get-pickup-estimate)
  ; show (word "Number of removed: " num-removed)
end

to-report get-passenger-destinations
  ;; Return the destinations of all passengers as a list
  let destinations []

  foreach bus_passengers
  [
    set destinations fput item 1 ? destinations
  ]

  report destinations
end

;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                                   BUS LOGIC
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

to pick-destination
  ;; To pick an optimal destination for the bus
  ; show (word "Blacklist " blacklisted-stops)
  let most-requested-tuple get-most-requested-stop
  let max-waiting-stop-tuple []
  let max-waiting-stop get-max-waiting-stop
  set max-waiting-stop-tuple fput max-waiting-stop max-waiting-stop-tuple
  set max-waiting-stop-tuple lput length get-passengers-at-stop max-waiting-stop max-waiting-stop-tuple

  ; Choose the max of "most requested destination at the stop" and "stop with the most waiting people"
  ifelse item 1 most-requested-tuple > item 1 max-waiting-stop-tuple
  [
      set target-stop item 0 most-requested-tuple
  ]
  [
      set target-stop item 0 max-waiting-stop-tuple
  ]
end

to-report get-waiting-passengers
  ;; Count the total number of passengers waiting at all stations
  let waiting-passengers 0
  let bus-stop 0

  while [ bus-stop != 23 ]
  [
    set waiting-passengers waiting-passengers + length get-passengers-at-stop bus-stop
    set bus-stop bus-stop + 1
  ]

  report waiting-passengers
end

to-report bus-full?
  ;; Check whether the buses' capacity has been reached yet.
  report length bus_passengers = get-capacity
end

to-report get-capacity
  ;; Return the passenger capacity of the current bus
  if bus_type = 1
  [
    report 12
  ]

  if bus_type = 2
  [
    report 60
  ]

  if bus_type = 3
  [
    report 150
  ]
end

to call-in-reinforcements
  ;; Call for a new bus in case the current fleet cannot handle all the passengers (only the last bus added can call for a new bus)
  ; set ratio get-waiting-passengers / count buses

  let total-waiting-passengers get-waiting-passengers
  let available-capacity capacity

  foreach known-buses-capacity
  [
    set available-capacity available-capacity + ?
  ]

  set ratio total-waiting-passengers / available-capacity


  ifelse vote-in-progress?
  [
    ifelse voting-duration > 5 or voting-finished
    [
        let new-bus-type analyze-bus-type-votes
        show (word "Voting Done -> New bus_type: " new-bus-type)
        add-bus new-bus-type
        set called-reinforcements? true

        ; Init a new bus
        ask buses with [ current_stop = 3 and not initialized? ] [
          init-buses
        ]
        set vote-in-progress? false
        set voting-duration 0
        set received-votes []
    ]
    [
        ; show (word "Voting in Progress")
        set voting-duration voting-duration + 1
    ]
  ]
  [
    if not called-reinforcements? and ratio > 5 and ticks-since-init != 0
    [
        ; This is the case when the first bus wants to call reinforcements
        ifelse length known-buses = 0
        [
            let bus-type-threshold sum disappointments / length disappointments
            let new-bus-type 0
            ifelse bus-type-threshold > 150
            [
               set new-bus-type 3
            ]
            [
               ifelse bus-type-threshold > 50 and bus-type-threshold < 150
               [
                   set new-bus-type 2
               ]
               [
                   set new-bus-type 1
               ]
            ]
            add-bus new-bus-type
            set called-reinforcements? true

            ; Init a new bus
            ask buses with [ current_stop = 3 and not initialized? ] [
              init-buses
            ]
        ]
        [
            ; show (word "Initiate Voting")
            set vote-in-progress? true
            ask-votes
        ]
    ]
  ]
end

to-report get-max-waiting-stop
  ;; Return out of all stops except the current stop and blacklisted stop, the stop with the max people waiting
  let max-waiting-stop 3
  let max-waiting-passengers -1
  let bus-stop 0
  let candidate-destination []

  while [bus-stop != 23]
  [
    set candidate-destination fput bus-stop candidate-destination
    set bus-stop bus-stop + 1
  ]

  foreach blacklisted-stops
  [
    set candidate-destination remove ? candidate-destination
  ]

  foreach candidate-destination
  [
    let waiting-passengers length get-passengers-at-stop ?
    if max-waiting-passengers < waiting-passengers and ? != current_stop
    [
      set max-waiting-stop ?
      set max-waiting-passengers waiting-passengers
    ]
  ]

  report max-waiting-stop
end

to-report get-most-requested-stop
  ;; Return the most requested destination stop at the current stop
  let passenger-at-stop get-passengers-at-stop current_stop
  let destination-counter table:make
  let bus-stop-i 0
  let max-passenger-stop 0
  let max-passenger-stop-count -1

  ; Add the remaining passengers in the bus too for this calculation
  foreach bus_passengers
  [
    set passenger-at-stop lput ? passenger-at-stop
  ]

  while [bus-stop-i <= 23]
  [
    table:put destination-counter bus-stop-i 0
    set bus-stop-i bus-stop-i + 1
  ]

  foreach passenger-at-stop
  [
    let destination-passengers table:get destination-counter item 1 ?
    table:put destination-counter item 1 ? destination-passengers + 1
  ]

  if table:has-key? destination-counter current_stop
  [
    table:remove destination-counter current_stop
  ]

  foreach table:to-list destination-counter
  [
    if item 1 ? > max-passenger-stop-count
    [
      set max-passenger-stop-count item 1 ?
      set max-passenger-stop item 0 ?
    ]
  ]

  let max-passenger-stop-tuple []
  set max-passenger-stop-tuple fput max-passenger-stop max-passenger-stop-tuple
  set max-passenger-stop-tuple lput max-passenger-stop-count max-passenger-stop-tuple

  report max-passenger-stop-tuple
end

; to-report get-pickup-estimate
;   ;; Returns the number of estimated passengers to be picked up in the itinerary
;   let temp-count 0
;
;   foreach itinerary
;   [
;     let current-passengers get-passengers-at-stop ?
;     foreach current-passengers
;     [
;         if member? item 1 ? itinerary
;         [
;             set temp-count temp-count + 1
;         ]
;     ]
;   ]
;   report temp-count
; end

to-report get-least-prefered-stop
    ;; Returns the least prefered stop among the passengers of the bus other than passangers who are in the itinerary
    let min-prefered-stop 24
    let min-prefered-stop-count 200

    foreach table:to-list passenger-destination-count
    [
      if item 1 ? < min-prefered-stop-count and item 1 ? != 0 and not member? item 0 ? itinerary
      [
        set min-prefered-stop-count item 1 ?
        set min-prefered-stop item 0 ?
      ]
    ]

    report min-prefered-stop
end

to-report try-remove-passenger
    ;; Removes a less important passenger to give way for a more important passenger
    let removed 0
    let least-prefered-stop get-least-prefered-stop
    ; show (word "Passangers counts "table:to-list passenger-destination-count)
    ; show (word "Least prefered stop: " least-prefered-stop)

    foreach bus_passengers
    [
        if item 1 ? = least-prefered-stop and removed = 0
        [
            drop-off-passenger item 0 ?
            set removed 1
            let temp-count table:get passenger-destination-count item 1 ?
            table:put passenger-destination-count item 1 ? temp-count - 1
        ]
    ]

    report removed
end
