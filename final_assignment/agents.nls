__includes [ "messaging.nls" "routing.nls" ]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".

  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  itinerary               ; List of next stations to visit
  target-stop             ; Next stop the bus is driving towards
  called-reinforcements?  ; Flag indicating whether this bus has already called a new bus
  initialized?            ; Flag indicating whether this bus has been initialized yet
  ratio                   ; Ratio of buses to waiting passengers
  ticks-since-init        ; Records the ticks since the bus has been initialized
  path-destination        ; Records the shortest path to the destination
  capacity                ; Total capacity of bus
  pending-contracts       ; table of open / pending requests to other buses
  assigned-contracts      ; table of requests received by other buses
  reactions               ; List of tasks of function that are used to react to an incoming request by another bus
  return-path             ; List of stations the bus drives by to return to schedule            
]
 
extensions [table]
globals [graph]

to init-buses
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  ; 0: Amstel, 1: Amstelveenseweg, 2: Buikslotermeer, 3: Centraal, 4: Dam
  ; 5: Evertsenstraat, 6: Floradorp, 7: Haarlemmermeerstation, 8: Hasseltweg, 9: Hendrikkade,
  ; 10: Leidseplein, 11: Lelylaan, 12: Muiderpoort, 13: Museumplein, 14: RAI, 15: SciencePark, 16: Sloterdijk,
  ; 17: Surinameplein, 18: UvA, 19: VU, 20: Waterlooplein, 21: Weesperplein, 22: Wibautstraat, 23: Zuid

  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  
  ; Initialize your agents here.
  set target-stop 0
  set itinerary generate-schedule
  set return-path []
  set target-stop pick-destination
  set called-reinforcements? false
  set initialized? true
  set ticks-since-init 0
  set pending-contracts table:make
  set assigned-contracts table:make
  set reactions (list (task message-test-answer)) ; Add new reaction to requests as tasks here
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.

  ; Check if a new bus should be used
  call-in-reinforcements
  set ticks-since-init ticks-since-init + 1

  ; Message management
  process-inbox
  answer-questions
  ask-questions

  ; Check if itinerary is finished, if yes recreate it
  if length itinerary = 0
  [
    set itinerary generate-schedule
  ]

  ifelse current_stop = target-stop
  ; Bus is at a station
  [
    drop-off-at-station
    pick-up-at-station
    set target-stop pick-destination
  ]
  ; Bus is still on the road
  [
    travel-to target-stop
  ]

end

;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                             PASSENGER MANAGEMENT
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

to drop-off-at-station
  ;; Drop off all the passengers at station in case it's their destination.
  foreach bus_passengers
  [
    if item 1 ? = current_stop
    [
      drop-off-passenger item 0 ?
    ]
  ]
end

to pick-up-at-station
  ;; Pick up all the passenger at a bus stop.
  foreach get-passengers-at-stop current_stop
  [
    if not bus-full?
    [
      pick-up-passenger item 0 ?
    ]
  ]
end

to-report get-passenger-destinations
  ;; Return the destinations of all passengers as a list
  let destinations []
  
  foreach bus_passengers
  [
    set destinations fput item 1 ? destinations
  ]
  
  report destinations
end

;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                                   BUS LOGIC
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

to-report pick-destination
  ;; Pick the next destination of the bus
  ;; Follow this decision tree?
  ;; 1. Is the the bus returning to schedule? 
  ;;    Yes: Get next next station on shortest path back to schedule.
  ;;    No: 2. Calculate utilization of vehicle.
  ;;        Utilization > 50 %: Try to pick next stop based on the passengers in the bus. Report most requested station
  ;;        Utilization < 50 %: Try to pick next stop based on passengers waiting there. Report most frequented station
  ;;        3. No good decision could be made: Return to schedule. 
  let target 0
  
  ; Return to original schedule after heuristics 
  if length return-path > 0
  [
     ;show "Still returning to schedule"
     set target item 0 return-path
     ;show (word "Next up " target)
     set return-path remove-item 0 return-path
     report target
  ]
  
  let utilization length bus_passengers / get-capacity
  ; If bus is under 50 % utilization -> Pick up more people first
  ifelse utilization < 0.5
  [
    set target pick-most-frequented-station
    ;show "Pick most frequented station."
    ;show (word "Picked " target)
  ]
  
  ; If bus is over 50 % utilization -> Deliver passengers
  [
    set target pick-most-requested-station
    ;show "Pick most requested station."
    ;show (word "Picked " target)
  ]
  
  ; If the previous heuristic were indifferent
  if target = -1
  [
    ;show "Heuristic was insufficent, just pick next stop."
    ; TODO: Add path if next regular station is further away
    set target item 0 itinerary
    ;show (word "Checking shortest path from " current_stop " to " target)
    let raw-return-path get-path-destination current_stop target
    
    ifelse length raw-return-path > 1
    [
      ;show (word "Shortest return path is " raw-return-path)
      set return-path raw-return-path
      set target item 0 return-path
      set return-path remove-item 0 return-path
    ]
    [
      ;show (word "Shortest path not necessary")
      set itinerary remove-item 0 itinerary
    ]
  ]
  ;show (word "Next up " target)
  report target
end

to-report frequency [i lst]
  report length filter [? = i] lst
end

to-report pick-most-requested-station
  ;; Pick next station based on the station most passenger being carried by the bus want to go to 
  let passenger-destination get-passenger-destinations
  
  ; Find frequency of requested stations
  let destination-freqs map [frequency ? passenger-destination] n-values 24 [? + 1]
  
  ; Find most requested stop
  let max-value max destination-freqs
  let max-index position max-value destination-freqs
   
  ; Don't change schedule is stop is only requested by a few people
  if max-value > 3 and max-index != current_stop
  [
    ;show (word "Checking shortest path from " current_stop " to most requested " max-index)
    let raw-return-path get-path-destination current_stop max-index
    
    if length raw-return-path > 1
    [
      ;show (word "Shortest return path to most requested is " raw-return-path)
      set return-path raw-return-path
      let target item 0 return-path
      set return-path remove-item 0 return-path
      
      report target
    ]
    
    report max-index
  ]
 
  ; Being indifferent
  report -1
end

to-report pick-most-frequented-station
  ;; Pick next station based on the number of passengers waiting at the stop
  let neighboring-stops item current_stop graph
  let waiting-at-stop []
  
  foreach neighboring-stops
  [
    set waiting-at-stop lput length get-passengers-at-stop ? waiting-at-stop
  ]
  
  ; Find most requested stop
  let max-value max waiting-at-stop
  let max-index position max-value waiting-at-stop
  
  ; Don't change schedule is stop is only frequented by a few people
  if max-value > 3
  [
    report item max-index neighboring-stops
  ]
    
  ; Being indifferent
  report -1
end

to-report generate-schedule
  ;; Generate a boring planned out bus schedule that a vehicle follows relentlessly.
  ;; (Assuming that Centraal is a hub where people want to go more often than to other stations)
  let schedule [
    3 9 8 6 8 2 8 9 3 ; Amsterdam Noord
    9 20 12 15 18 15 0 22 21 20 3 ; Amsterdam Oost / Zuid-Oost
    4 10 13 23 14 23 19 1 7 17 11 16 5 4 3 ;; Amsterdam Zuid / West
  ]

  ;; Let buses drive the route into the other direction with a 50:50 probability
  if random 2 = 0
  [
    set schedule reverse schedule
  ]

  report schedule
end

to call-in-reinforcements
  ;; Call for a new bus in case the current fleet cannot handle all the passengers (only the last bus added can call for a new bus)
  set ratio get-waiting-passengers / count buses

  if not called-reinforcements? and ratio > 50 and ticks-since-init > 30
  [
    let new-bus-type determine-new-bus-type
    add-bus new-bus-type
    set called-reinforcements? true

    ; Init a new bus
    ask buses with [ current_stop = 3 and not initialized? ] [
      init-buses
    ]
  ]
end

to-report get-waiting-passengers
  ;; Count the total number of passengers waiting at all stations
  let waiting-passengers 0
  let bus-stop 0

  while [ bus-stop != 23 ]
  [
    set waiting-passengers waiting-passengers + length get-passengers-at-stop bus-stop
    set bus-stop bus-stop + 1
  ]

  report waiting-passengers
end

to-report bus-full?
  ;; Check whether the buses' capacity has been reached yet.
  report length bus_passengers = get-capacity
end

to-report get-capacity
  ;; Return the passenger capacity of the current bus
  if bus_type = 1
  [
    report 12
  ]

  if bus_type = 2
  [
    report 60
  ]

  if bus_type = 3
  [
    report 150
  ]
end

to-report determine-new-bus-type
  if ratio >= 500
  [
    report 3
  ]

  ifelse ratio > 100 and ratio < 500
  [
    report 2
  ]
  [
    report 1
  ]
end

