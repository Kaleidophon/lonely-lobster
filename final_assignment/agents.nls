
buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  itinerary               ; List of next stations to visit
  target-stop             ; Next stop the bus is driving towards
  called-reinforcements?  ; Flag indicating whether this bus has already called a new bus
  initialized?            ; Flag indicating whether this bus has been initialized yet
  ratio                   ; Ratio of buses to waiting passengers
  ticks-since-init        ; Records the ticks since the bus has been initialized
  capacity                ; Total capacity of bus
  pending-contracts       ; table of open / pending requests to other buses
  assigned-contracts      ; table of requests received by other buses
  reactions               ; List of tasks of function that are used to react to an incoming request by another bus             
]
 
extensions [table]
globals [graph]

to init-buses
  ; Initialize your agents here.
  set itinerary generate-schedule
  pick-destination
  set called-reinforcements? false
  set initialized? true
  set ticks-since-init 0
  set pending-contracts table:make
  set assigned-contracts table:make
  set reactions (list (task message-test-answer)) ; Add new reaction to requests as tasks here

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  ; 0: Amstel, 1: Amstelveenseweg, 2: Buikslotermeer, 3: Centraal, 4: Dam
  ; 5: Evertsenstraat, 6: Floradorp, 7: Haarlemmermeerstation, 8: Hasseltweg, 9: Hendrikkade,
  ; 10: Leidseplein, 11: Lelylaan, 12: Muiderpoort, 13: Museumplein, 14: RAI, 15: SciencePark, 16: Sloterdijk,
  ; 17: Surinameplein, 18: UvA, 19: VU, 20: Waterlooplein, 21: Weesperplein, 22: Wibautstraat, 23: Zuid

  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  ;get-all-distances
  let distances read-distances 
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  ; Check if a new bus should be used
  call-in-reinforcements
  set ticks-since-init ticks-since-init + 1
  
  ; Message management
  process-inbox
  answer-questions
  ask-questions
  
  ; Check if itinerary is finished, if yes recreate it
  if length itinerary = 0 
  [
    set itinerary generate-schedule
  ]
  
  ifelse current_stop = target-stop
  ; Bus is at a station
  [
    drop-off-at-station
    pick-up-at-station
    pick-destination
  ]
  ; Bus is still on the road
  [
    travel-to target-stop
  ]
end

;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                             PASSENGER MANAGEMENT
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

to drop-off-at-station
  ;; Drop off all the passengers at station in case it's their destination.
  foreach bus_passengers
  [
    if item 1 ? = current_stop 
    [
      drop-off-passenger item 0 ?
    ]
  ]
end

to pick-up-at-station
  ;; Pick up all the passenger at a bus stop.
  foreach get-passengers-at-stop current_stop
  [
    if not bus-full?
    [
      pick-up-passenger item 0 ?
    ]
  ]
end

to-report get-passenger-destinations
  ;; Return the destinations of all passengers as a list
  let destinations []
  
  foreach bus_passengers
  [
    set destinations fput item 1 ? destinations
  ]
  
  report destinations
end

;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                                   BUS LOGIC
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

to pick-destination
  ;; Pick the next destination of the bus
  set target-stop item 0 itinerary
  set itinerary remove-item 0 itinerary
end


to-report generate-schedule
  ;; Generate a boring planned out bus schedule that a vehicle follows relentlessly.
  ;; (Assuming that Centraal is a hub where people want to go more often than to other stations)
  let schedule [ 
    3 9 8 6 8 2 8 9 3 ; Amsterdam Noord
    9 20 12 15 18 15 0 22 21 20 3 ; Amsterdam Oost / Zuid-Oost
    4 10 13 23 14 23 19 1 7 17 11 16 5 4 3 ;; Amsterdam Zuid / West
  ]
  
  ;; Let buses drive the route into the other direction with a 50:50 probability
  if random 2 = 0
  [
    set schedule reverse schedule
  ]
  
  report schedule
end

to call-in-reinforcements
  ;; Call for a new bus in case the current fleet cannot handle all the passengers (only the last bus added can call for a new bus)
  set ratio get-waiting-passengers / count buses
  
  if not called-reinforcements? and ratio > 50 and ticks-since-init > 30
  [
    let new-bus-type determine-new-bus-type
    add-bus new-bus-type
    set called-reinforcements? true
 
    ; Init a new bus
    ask buses with [ current_stop = 3 and not initialized? ] [
      init-buses
    ]
  ]
end

to-report get-waiting-passengers
  ;; Count the total number of passengers waiting at all stations
  let waiting-passengers 0
  let bus-stop 0
  
  while [ bus-stop != 23 ]
  [
    set waiting-passengers waiting-passengers + length get-passengers-at-stop bus-stop
    set bus-stop bus-stop + 1
  ]
  
  report waiting-passengers
end

to-report bus-full?
  ;; Check whether the buses' capacity has been reached yet.
  report length bus_passengers = get-capacity
end

to-report get-capacity
  ;; Return the passenger capacity of the current bus
  if bus_type = 1
  [
    report 12
  ]
  
  if bus_type = 2
  [
    report 60
  ]
  
  if bus_type = 3
  [
    report 150
  ]
end

to-report determine-new-bus-type
  if ratio >= 500
  [
    report 3
  ]
  
  ifelse ratio > 100 and ratio < 500
  [
    report 2
  ]
  [
    report 1
  ]
end

;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                                   MESSAGING
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

;; The messaging with contracts logic works the following way
;; First of all, a bus goes through its mailbox, looking for reponses to contracts it assigned to other buses 
;; or contracts is has been assigned to by other buses (process-inbox).
;; If there are any, it tries to process them accordingly (answer-questions), which can happen in to cases:
;;   a) It is a notification that the contract is has assigned to another bus has been fulfilled. The corresponding
;;      pending contract we be marked as fulfilled.
;;   b) It is a contract assigned by another bus: Add it to the list of assigned-contracts and try to process it immediately.
;;      These ways to process a possible request should be functions added to the <reaction> variable of each bus.
;;
;; Afterwards, the bus gets "curious" itself and asks other buses questions (ask-questions).
;; The conditions for these questions should be defined in the question function itself to keep the code more readable.
;; In case the bus asks a question, a pending contract is created and added to pending-contracts. The message is sent
;; to the bus in question, containing the act ("ASK", "DO", ...), the id of the ID and the receiver and the sender
;; and the ID of the bus the contract originated from and the bus it was assigned to (because that will be the other 
;; way around once a contract is send back to its original contractor). Once the target bus has received the message with the
;; contract, it performs the steps described above.

to process-inbox
  ;; Process inbox, generate new assigned contracts for every contract received by another bus
  while [ length inbox > 0 ]
  [
    let current-mail item 0 inbox
    set inbox remove-item 0 inbox
    set current-mail item 2 current-mail ; If you send a message, it gets wrapped in another list
    let contract-id table:get current-mail "contract-id"
    let contract-to table:get current-mail "contract-to"
    
    let res fulfill-pending-contract contract-id current-mail
    
    ; If the current contract hasn't been a response by another bus, it is a contract assignt TO this bus
    ; So add it as a assigned contract
    if not res and contract-to = bus_id
    [
      add-assigned-contract contract-id current-mail
    ]
  ]
end

to ask-questions
  ;; Ask other buses for some sort of information
  ;; Put all the requests done during every tick here
  message-test-request
end

to answer-questions
  ;; Answer requests by other buses
  ;; Put all the logic a bus uses to react to a certain request here
  foreach table:keys assigned-contracts
  [    
    ;; Perform reactions to a message
    let reacted? false
    let reaction-index 0
    
    while [ not reacted? and reaction-index < length reactions ]
    [
      let current-reaction item reaction-index reactions
      let current-contract table:get assigned-contracts ?
      set reacted? (runresult current-reaction current-contract)
      
      set reaction-index reaction-index + 1
    ]
  ]
  
end

to message-test-request
  ;; Have a bus introduce itself after its creation
  ;; TODO: This is just to test the messaging logic. Remove later.
  
  if ticks-since-init = 1 ; Introduce bus to other buses only once
  [
     let action "ASK"
     let content (word "I am bus " bus_id ". Please return my handshake?")
     
     let bus_index 24
     
     ; Send message to all other buses
     while [ bus_index < bus_id ]
     [
       send-message-with-contract bus_index action content (task message-test-callback)
       set bus_index bus_index + 1
     ]
  ]
end

to-report message-test-answer [ request ]
  let sender-action table:get request "action"
  
  if sender-action = "ASK"
  [
    let sender-id table:get request "sender"
    let contract-id table:get request "contract-id"
    let response (word "Hello bus " sender-id "!")
    let action "RESPOND"
  
    let message create-message contract-id sender-id action response
    table:put message "contract-from" table:get request "contract-from"
    table:put message "contract-to" table:get request "contract-to"
    send-message sender-id message
    report fulfill-assigned-contract contract-id
  ]
  
  report false
end

to-report message-test-callback [ response ]
  ;; Verify that the handshake has been successful.
  ;; TODO: This is just to test the messaging logic. Remove later.
  
  let sender table:get response "sender"
  let content table:get response "content"
  
  show (word "Bus " sender " says: " content)
  report true
end

to send-message-with-contract [ receiver action content callback ]
  ;; Send a message to another bus and create a contract. 
  ;; The contract is deemd fulfilled once the bus receives a response from the addressed bus.
  let contract-id generate-contract-id
  let message create-message contract-id receiver action content
  table:put message "contract-from" bus_id
  table:put message "contract-to" receiver
  
  add-pending-contract contract-id callback
  send-message receiver message
end

to add-pending-contract [ contract-id callback ]
  ;; Add a new contract to the table of pending contracts
  table:put pending-contracts contract-id callback
  show (word "Generated new pending contract " contract-id)
end

to-report fulfill-pending-contract [ contract-id response ]
  ;; Fulfill an existing contract and execute the callback function
  carefully [
    let callback table:get pending-contracts contract-id
    table:remove pending-contracts contract-id ; Remove contract; it has been fulfilled
    show (word "Fulfilling pending contract " contract-id)
    report (runresult callback response) ; Feed the response of another bus into the contract callback
  ]
  [
    report false
  ]
end

to add-assigned-contract [ contract-id request ]
  ;; Add a new contract to the table of contracts assigned to this bus
  table:put assigned-contracts contract-id request
  show (word "Received assigned contract " contract-id)
end

to-report fulfill-assigned-contract [ contract-id ]
  ;; Fulfill a contract that has been assigned to this bus by another bus
  carefully [
    table:remove assigned-contracts contract-id ; Remove contract; it has been fulfilled
    show (word "Fulfilling assigned contract " contract-id)
    report true
  ]
  [
    report false
  ]
end

to-report create-message [ contract-id receiver action content ]
  ;; Compose a full message out of its path
  let message table:make
  
  table:put message "contract-id" contract-id
  table:put message "receiver" receiver
  table:put message "sender" bus_id
  table:put message "action" action
  table:put message "content" content
  
  report message
end

to-report compile-info
  ;; Compile information about the current bus in order to exchange it with other buses
  let info table:make
  
  table:put info "bus-id" bus_id
  table:put info "target" target-stop
  table:put info "num-passengers" length bus_passengers
  table:put info "total-capacity" get-capacity
  table:put info "capacity-left" get-capacity - length bus_passengers
  table:put info "itinerary" itinerary
  table:put info "destinations" get-passenger-destinations
  
  report info
end

to-report generate-contract-id
  ;; Generate a (hopefully) unique id for a contract
  let contract-id (word bus_id ":" word ticks-since-init ":" random 100)
  report contract-id
end

;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                                   DISTANCES
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

to-report read-distances
  ;; Read distances between bus stops from a file
  let distances table:make
  file-open "distances.txt"

  while [ not file-at-end? ]
  [
    let from-stop file-read
    let to-stop file-read
    let dist file-read
    let key (list from-stop to-stop)
    table:put distances key dist
  ]
  
  file-close
  report distances
end

to get-all-distances
  ;; Retrieve the distances between all the bus stops and write them into a file
  let bus-stop-i 0
  let bus-stop-j 0
  
  while [bus-stop-i <= 23]
  [
    while [bus-stop-j <= 23]
    [
      if bus-stop-j > bus-stop-i  ; Don't consider the reverse direction if you alreay calculated it
      [
        let dist get-distance bus-stop-i bus-stop-j
        
        if dist != -1
        [
          file-open "distances.txt"
          ; Both directions, graph is not directional
          file-write bus-stop-i file-write bus-stop-j file-write dist file-print ""
          file-write bus-stop-j file-write bus-stop-i file-write dist file-print ""
          file-flush
          file-close
        ]
      ]
      
      set bus-stop-j bus-stop-j + 1
    ]
    set bus-stop-i bus-stop-i + 1
    set bus-stop-j 0
  ]
end
