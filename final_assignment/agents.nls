__includes [ "messaging.nls" "routing.nls" ]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".

  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  itinerary               ; List of next stations to visit
  target-stop             ; Next stop the bus is driving towards
  called-reinforcements?  ; Flag indicating whether this bus has already called a new bus
  initialized?            ; Flag indicating whether this bus has been initialized yet
  ratio                   ; Ratio of buses to waiting passengers
  ticks-since-init        ; Records the ticks since the bus has been initialized
  path-destination        ; Records the shortest path to the destination
  blacklisted-stops       ; Records the stops it isn't supposed to use as destination
  capacity                ; Total capacity of bus
  pending-contracts       ; table of open / pending requests to other buses
  assigned-contracts      ; table of requests received by other buses
  reactions               ; List of tasks of function that are used to react to an incoming request by another bus
]

extensions [table]
globals [graph]

to init-buses

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  ; 0: Amstel, 1: Amstelveenseweg, 2: Buikslotermeer, 3: Centraal, 4: Dam
  ; 5: Evertsenstraat, 6: Floradorp, 7: Haarlemmermeerstation, 8: Hasseltweg, 9: Hendrikkade,
  ; 10: Leidseplein, 11: Lelylaan, 12: Muiderpoort, 13: Museumplein, 14: RAI, 15: SciencePark, 16: Sloterdijk,
  ; 17: Surinameplein, 18: UvA, 19: VU, 20: Waterlooplein, 21: Weesperplein, 22: Wibautstraat, 23: Zuid

  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]

  ; Initialize your agents here.
  pick-destination
  show (word "Destination: " target-stop)
  set itinerary get-path-destination
  show (word "New Itinerary: " itinerary)
  set called-reinforcements? false
  set initialized? true
  set ticks-since-init 0
  ; set pending-contracts table:make
  ; set assigned-contracts table:make
  ; set reactions (list (task message-test-answer)) ; Add new reaction to requests as tasks here
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.

  ; Check if a new bus should be used
  call-in-reinforcements
  set ticks-since-init ticks-since-init + 1

  ; Message management
  ; process-inbox
  ; answer-questions
  ; ask-questions

  ; Check if itinerary is finished, if yes recreate it
  ; if length itinerary = 0
  ; [
  ;   set itinerary generate-schedule
  ; ]

  ifelse current_stop = target-stop
  ; Bus is at a station
  [
    show (word "At destination")
    drop-off-at-station
    pick-destination
    ; show (word "Destination: " target-stop)
    pick-up-at-station
    set itinerary get-path-destination
    ; show (word "New Itinerary: " itinerary)
  ]
  ; Bus is still on the road
  [
    show (word "Still on road at " current_stop)
    show (word "Next-stop " next_stop)
    ifelse current_stop = -1
    [
      travel-to next_stop
    ]
    [
      drop-off-at-station
      pick-up-at-station
      let got-to-stop item 0 itinerary
      set itinerary remove-item 0 itinerary
      ; show (word "Go-to-stop " got-to-stop)
      travel-to got-to-stop
    ]
  ]

  ; show (word "Maximum waiting stop: " get-max-waiting-stop)

end

;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                             PASSENGER MANAGEMENT
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

to drop-off-at-station
  ;; Drop off all the passengers at station in case it's their destination.
  foreach bus_passengers
  [
    if item 1 ? = current_stop
    [
      drop-off-passenger item 0 ?
    ]
  ]
end

; ; Old pick-up-at-station
; to pick-up-at-station
;   ;; Pick up all the passenger at a bus stop.
;   foreach get-passengers-at-stop current_stop
;   [
;     if not bus-full?
;     [
;       pick-up-passenger item 0 ?
;     ]
;   ]
; end

; New pick-up-at-station
to pick-up-at-station
  ;; Pick up all the passengers whose destination is in the itinerary
  foreach itinerary
  [
    let stop-i ?

    foreach get-passengers-at-stop current_stop
    [
      if not bus-full? and item 1 ? = stop-i
      [
        pick-up-passenger item 0 ?
      ]
    ]
  ]
end


to-report get-passenger-destinations
  ;; Return the destinations of all passengers as a list
  let destinations []

  foreach bus_passengers
  [
    set destinations fput item 1 ? destinations
  ]

  report destinations
end

;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                                   BUS LOGIC
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

; ; Old pick destination
; to pick-destination
;   ;; Pick the next destination of the bus
;   set target-stop item 0 itinerary
;   set itinerary remove-item 0 itinerary
; end
;
; ; Old generate schedule
; to-report generate-schedule
;   ;; Generate a boring planned out bus schedule that a vehicle follows relentlessly.
;   ;; (Assuming that Centraal is a hub where people want to go more often than to other stations)
;   let schedule [
;     3 9 8 6 8 2 8 9 3 ; Amsterdam Noord
;     9 20 12 15 18 15 0 22 21 20 3 ; Amsterdam Oost / Zuid-Oost
;     4 10 13 23 14 23 19 1 7 17 11 16 5 4 3 ;; Amsterdam Zuid / West
;   ]
;
;   report schedule
; end

; New pick destination
to pick-destination

  ifelse ticks-since-init = 0
  [
    set target-stop get-max-waiting-stop
  ]
  [
    let max-destination-tuple get-max-passenger-stop
    let max-waiting-stop get-max-waiting-stop
    let max-waiting-stop-tuple []
    set max-waiting-stop-tuple fput max-waiting-stop max-waiting-stop-tuple
    set max-waiting-stop-tuple lput length get-passengers-at-stop max-waiting-stop max-waiting-stop-tuple

    ifelse item 1 max-destination-tuple > item 1 max-waiting-stop-tuple
    [
      ifelse current_stop != item 0 max-destination-tuple
      [
        set target-stop item 0 max-destination-tuple
      ]
      [
        set target-stop item 0 max-waiting-stop-tuple
      ]
    ]
    [
      ifelse current_stop != item 0 max-waiting-stop-tuple
      [
        set target-stop item 0 max-waiting-stop-tuple
      ]
      [
        set target-stop item 0 max-destination-tuple
      ]
    ]
  ]

end


to call-in-reinforcements
  ;; Call for a new bus in case the current fleet cannot handle all the passengers (only the last bus added can call for a new bus)
  set ratio get-waiting-passengers / count buses

  if not called-reinforcements? and ratio > 50 and ticks-since-init > 30
  [
    let new-bus-type determine-new-bus-type
    add-bus new-bus-type
    set called-reinforcements? true

    ; Init a new bus
    ask buses with [ current_stop = 3 and not initialized? ] [
      init-buses
    ]
  ]
end

to-report get-waiting-passengers
  ;; Count the total number of passengers waiting at all stations
  let waiting-passengers 0
  let bus-stop 0

  while [ bus-stop != 23 ]
  [
    set waiting-passengers waiting-passengers + length get-passengers-at-stop bus-stop
    set bus-stop bus-stop + 1
  ]

  report waiting-passengers
end

to-report bus-full?
  ;; Check whether the buses' capacity has been reached yet.
  report length bus_passengers = get-capacity
end

to-report get-capacity
  ;; Return the passenger capacity of the current bus
  if bus_type = 1
  [
    report 12
  ]

  if bus_type = 2
  [
    report 60
  ]

  if bus_type = 3
  [
    report 150
  ]
end

to-report determine-new-bus-type
  if ratio >= 500
  [
    report 3
  ]

  ifelse ratio > 100 and ratio < 500
  [
    report 2
  ]
  [
    report 1
  ]
end

to-report get-max-waiting-stop
  let max-waiting-stop 3
  let max-waiting-passengers -1
  let bus-stop 0

  while [ bus-stop != 23 ]
  [
    let waiting-passengers length get-passengers-at-stop bus-stop
    if max-waiting-passengers < waiting-passengers
    [
      set max-waiting-stop bus-stop
      set max-waiting-passengers waiting-passengers
    ]
    set bus-stop bus-stop + 1
  ]

  report max-waiting-stop
end

to-report get-max-passenger-stop
  let passenger-at-stop get-passengers-at-stop current_stop
  let destination-counter table:make
  let bus-stop-i 0
  let max-passenger-stop 0
  let max-passenger-stop-count -1

  while [bus-stop-i <= 23]
  [
    table:put destination-counter bus-stop-i 0
    set bus-stop-i bus-stop-i + 1
  ]

  foreach passenger-at-stop
  [
    let destination-passengers table:get destination-counter item 1 ?
    table:put destination-counter item 1 ? destination-passengers + 1
  ]

  foreach table:to-list destination-counter
  [
    if item 1 ? > max-passenger-stop-count
    [
      set max-passenger-stop-count item 1 ?
      set max-passenger-stop item 0 ?
    ]
  ]

  let max-passenger-stop-tuple []
  set max-passenger-stop-tuple fput max-passenger-stop max-passenger-stop-tuple
  set max-passenger-stop-tuple lput max-passenger-stop-count max-passenger-stop-tuple

  report max-passenger-stop-tuple

end

; to-report get-passenger-destinations
;   ;; Return the destinations of all passengers as a list
;   let destinations []
;
;   foreach bus_passengers
;   [
;     set destinations fput item 1 ? destinations
;   ]
;
;   report destinations
; end

; to-report pick-most-requested-station
;   ;; Pick next station based on the station most passenger being carried by the bus want to go to
;   let passenger-destination get-passenger-destinations
;
;   ; Find frequency of requested stations
;   let destination-freqs map [frequency ? passenger-destination] n-values 24 [? + 1]
;
;   ; Find most requested stop
;   let max-value max destination-freqs
;   let max-index position max-value destination-freqs
;
;   ; Don't change schedule is stop is only requested by a few people
;   if max-value > 3 and max-index != current_stop
;   [
;     ;show (word "Checking shortest path from " current_stop " to most requested " max-index)
;     let raw-return-path get-path-destination current_stop max-index
;
;     if length raw-return-path > 1
;     [
;       ;show (word "Shortest return path to most requested is " raw-return-path)
;       set return-path raw-return-path
;       let target item 0 return-path
;       set return-path remove-item 0 return-path
;
;       report target
;     ]
;
;     report max-index
;   ]
