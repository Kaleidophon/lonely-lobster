;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;;                                   DISTANCES
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

to-report get-path-destination [ from-stop to-stop ]
  let bus-stop-i 0
  let distance-to-source table:make ; To store the distance of the shortest path to the source node
  let backtrack table:make ; To keep track of the previous node in the path

  ; Initialize distance-to-source with 0 for source node and for others initialize with infinity
  while [bus-stop-i <= 23]
  [
    if bus-stop-i != from-stop
    [
      table:put distance-to-source bus-stop-i 999999
    ]
    set bus-stop-i bus-stop-i + 1
  ]
  table:put distance-to-source from-stop 0

  ; Heap to keep track of the nodes to find shortest path to the source
  let heap table:keys distance-to-source

  while [ not empty? heap]
  [
    let min-distance 9999999
    let min-index 0
    foreach heap
    [
      if table:get distance-to-source ? < min-distance
      [
        set min-distance table:get distance-to-source ?
        set min-index ?
      ]
    ]
    set heap remove min-index heap

    ; show (word "Heap " heap)

    foreach item min-index graph
    [
      let path-length table:get distance-to-source min-index + get-distance min-index ?
      if table:get distance-to-source ? > path-length
      [
        table:put distance-to-source ? path-length
        table:put backtrack ? min-index
      ]
    ]
    ; show (word "Distances from source " table:to-list distance-to-source)
  ]

  ; Backtrack to the source using the bracktrack table
  let backtrack-stop to-stop
  ; Variable to store the shortest path
  let shortest-path []

  ; Start by adding the target stop
  set shortest-path fput to-stop shortest-path

  while [ backtrack-stop != from-stop ]
  [
    set backtrack-stop table:get backtrack backtrack-stop
    ; Keep adding the previous node to the shortest path while backtracking to the source
    if backtrack-stop != from-stop
    [
      set shortest-path fput backtrack-stop shortest-path
    ]
  ]

  report shortest-path
end

to-report get-pickup-estimate
  ;; Estimating the number of people that are going to be picked up during the next few stops
  let temp-count 0

  foreach itinerary
  [
    let current-passengers get-passengers-at-stop ?
    foreach current-passengers
    [
        if member? item 1 ? itinerary
        [
            set temp-count temp-count + 1
        ]
    ]
  ]

  report temp-count
end

to-report get-remaining-capacity
  ;; Return the remaining capacity of the current bus, taking into account passengers at station 
  ;; of the current itinerary
  let remaining-capacity get-capacity
  set remaining-capacity remaining-capacity - length bus_passengers
  set remaining-capacity remaining-capacity - get-pickup-estimate
  report remaining-capacity
end

to-report unpack [ element ]
  report item 1 element
end

to-report frequency [i lst]
  report length filter [? = i] lst
end


to-report get-remaining-capacity2
  let projected-passengers bus_passengers
  let projected-capacity length bus_passengers
  let future-transfer-stops []
  
  ;if length table:keys future-transfers > 0
  ;[
  ;    set future-transfer-stops map unpack table:to-list future-transfers
  ;]

  foreach itinerary
  [
    let future-stop ?
    
    ; Account for people that are boarding the bus at future stops
    foreach projected-passengers
    [
        if future-stop = item 1 ?
        [ 
           set projected-capacity projected-capacity - 1
        ]
    ]
    
    ; Account for people who are leaving the bus at future stops as their final destination
    let current-passengers get-passengers-at-stop future-stop
    foreach current-passengers
    [ 
        if member? item 1 ? itinerary
        [
            set projected-capacity projected-capacity + 1
            set projected-passengers lput ? projected-passengers
        ]
    ]
    
    ; Account for people who are leaving the bus at future stops as their transfer stop
  ]
  set projected-capacity projected-capacity + length table:keys future-transfers
  report projected-capacity
end

to-report get-current-capacity
  let max-capacity get-capacity
  report max-capacity - length bus_passengers
end

to-report get-transfer-bus-for-passenger [ passenger ]
  ;; Get the IDs of all the buses that could potentionally pick up this passengers 
  ;; and get them to their final destination after the current bus dropped them off somewhere
  ;; along the way.
  let passenger-destination item 1 passenger
  let transfer-buses table:make  ; Table from bus-id -> possible transfer stop
  
  foreach table:keys bus-itineraries
  [
      let other-itinerary table:get bus-itineraries ?
      ;show (word "This: " itinerary)
      ;show (word "Other: " other-itinerary)
      let itinerary-set []
      set itinerary-set fput itinerary itinerary-set
      set itinerary-set fput other-itinerary itinerary-set
      
      let itinerary-intersection reduce intersect itinerary-set
      
      ; A transfer bus is a transfer bus if
      ; a) The passenger's destination is in the transfer buses' itinerary
      ; b) If there is an intersection between the current buses' itinerary and the transfer buses' itinerary
      ; c) If the passenger destinations comes after the transfer stop in the transfer-buses itinerary
      if length itinerary-intersection > 0
      [
          let transfer-stop item 0 itinerary-intersection 
          if member? passenger-destination other-itinerary and position transfer-stop other-itinerary < position passenger-destination other-itinerary and transfer-stop != current_stop
          [
              if transfer-tractable? transfer-stop other-itinerary
              [
                  report (list ? transfer-stop)
              ]
              ;report (list ? transfer-stop)
          ]
      ]
  ]
  
  report []
end

to-report intersect [a b]
   report (filter [ member? ? b ] a)
end

to-report transfer-tractable? [ transfer-stop other-itinerary ]
  ;; Having determined buses that could serve as a possible transfer bus at one of the stops
  ;; on this buses' itinerary, pick a stop that a passenger could be dropped off at for transfer.
  ;; If none could be found, the passenger shouldn't be picked up.
  let this-itinerary itinerary
  if current_stop != -1
  [
    set this-itinerary fput current_stop this-itinerary
  ]
  
  ; Get distance of current bus to transfer stop
  let this-distance-to-transfer get-distance-to-itinerary-stop transfer-stop this-itinerary
  
  ; Get distance of other bus to transfer stop
  let other-distance-to-transfer get-distance-to-itinerary-stop transfer-stop other-itinerary
  
  ;show (word "(This) Itinerary: " itinerary " |  Stop: " transfer-stop " | Distance: " this-distance-to-transfer)
  ;show (word "(Other) Itinerary: " other-itinerary " |  Stop: " transfer-stop " | Distance: " other-distance-to-transfer)
  
  if this-distance-to-transfer < other-distance-to-transfer
  [
    ;show "Insufficient"
    report true
    ;table:remove possible-transfer-buses ?
  ]
  report false
end

to-report get-distance-to-itinerary-stop [ itinerary-stop some-itinerary ]
  ;; Get the distance of bus from it's current stop to some other stop on its itinerary
  let distance-to-transfer 0
  let itinerary-i 0
  let last-stop -1
  let reached-transfer? false
  
  if item 0 some-itinerary != itinerary-stop
  [
    while [ not reached-transfer? and itinerary-i < length some-itinerary ]
    [
      let current-itinerary-stop item itinerary-i some-itinerary
      if itinerary-i > 0 and not reached-transfer?
      [
        set distance-to-transfer distance-to-transfer + get-distance last-stop current-itinerary-stop 
        if current-itinerary-stop = itinerary-stop
        [
          set reached-transfer? true
        ]
      ]
      
      set last-stop current-itinerary-stop
      set itinerary-i itinerary-i + 1
    ]
  ]
  
  report distance-to-transfer
end

to-report get-itinerary-length [ some-itinerary ]
  ;; Get the total length of an itinerary
  let total-distance 0
  let itinerary-i 1
  
  while [ itinerary-i < length some-itinerary ]
  [
     show (word "Dist " item (itinerary-i - 1) some-itinerary "-" item itinerary-i some-itinerary)
     set total-distance total-distance + get-distance (item (itinerary-i - 1) some-itinerary) (item itinerary-i some-itinerary)
     set itinerary-i itinerary-i + 1
  ]
  
  report total-distance
end

to-report get-stop-distance [ from-stop to-stop ]
  ;; Report the total distance between two stop, taking into account all the stops in between
  show (word "From " from-stop " to " to-stop)
  let itinerary-stops get-path-destination from-stop to-stop
  
  ;if item 0 itinerary-stops != from-stop
  ;[
  ;   set itinerary-stops fput from-stop itinerary-stops
  ;]
  show (word "Itinerary: " itinerary-stops)
  let itinerary-distance get-itinerary-length itinerary-stops
  show (word "Distance: " itinerary-distance)
  report itinerary-distance
end

